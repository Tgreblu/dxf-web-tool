<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore DXF per Laser - Parabiago Edition</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Paper.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
    <!-- Opentype.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        /* Altezza fissa per il canvas per evitare glitch di ridimensionamento */
        canvas[resize] { width: 100%; height: 400px; border: 1px solid #ccc; background-color: #fff; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4">

    <div class="max-w-4xl mx-auto bg-white rounded-lg shadow-lg p-6">
        <h1 class="text-2xl font-bold text-gray-800 mb-2">Generatore Campitura Laser (DXF R13)</h1>
        
        <!-- Area Stato/Errori -->
        <div id="appStatus" class="mb-4 p-3 bg-blue-50 text-blue-700 rounded-md text-sm border border-blue-200">
            Inizializzazione sistema...
        </div>

        <p class="text-gray-600 mb-6 text-sm">
            Inserisci il testo. Il sistema unirà automaticamente le geometrie sovrapposte (Boolean Union) per creare un outline pulito.
        </p>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <!-- Controlli -->
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Testo da marcare</label>
                    <input type="text" id="inputText" value="PARABIAGO" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2 focus:border-blue-500 focus:ring-blue-500" oninput="scheduleUpdate()">
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Spaziatura Linee (mm)</label>
                        <input type="number" id="hatchSpacing" value="0.5" step="0.1" min="0.1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2" onchange="scheduleUpdate()">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Angolo (gradi)</label>
                        <input type="number" id="hatchAngle" value="45" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2" onchange="scheduleUpdate()">
                    </div>
                </div>

                <div>
                     <label class="block text-sm font-medium text-gray-700">Dimensione Testo (px/unità)</label>
                     <input type="number" id="fontSize" value="150" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2" onchange="scheduleUpdate()">
                </div>
                
                <div class="flex items-center space-x-2 mt-2">
                     <input type="checkbox" id="includeOutline" checked onchange="scheduleUpdate()" class="rounded text-blue-600 focus:ring-blue-500">
                     <label for="includeOutline" class="text-sm text-gray-700">Includi Perimetro (Contorno Unito)</label>
                </div>

                <div class="pt-4">
                    <button id="btnDownload" onclick="downloadDXF()" disabled class="w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-gray-400 cursor-not-allowed transition-colors">
                        <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                        Scarica File DXF
                    </button>
                    <p id="calcStatus" class="text-xs text-center mt-2 text-gray-500"></p>
                </div>
            </div>

            <!-- Preview -->
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Anteprima (Rosso=Hatch, Blu=Outline Unito)</label>
                <!-- Canvas Paper.js -->
                <canvas id="previewCanvas" resize></canvas>
            </div>
        </div>
        
        <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 mt-4">
            <p class="text-sm text-yellow-700">
                <strong>Fix Applicato:</strong> Ora le lettere composte da più forme (come la "E" o lettere accentate) vengono fuse in un unico contorno prima di generare il file.
            </p>
        </div>
    </div>

    <!-- Logica Applicativa -->
    <script type="text/javascript">
        // --- Variabili Globali ---
        let font = null;
        let paperProject = null;
        let finalHatchGroup = null;
        let finalOutlineGroup = null;
        let updateTimer = null;
        let isReady = false;

        // Font URLs
        const FONT_URLS = [
            'https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/fonts/Roboto/Roboto-Regular.ttf',
            'https://cdn.jsdelivr.net/gh/google/fonts/apache/roboto/Roboto-Regular.ttf'
        ];

        // --- Utility UI ---
        function setStatus(msg, type = 'info') {
            const el = document.getElementById('appStatus');
            el.innerText = msg;
            const colors = {
                'error': 'bg-red-50 text-red-700 border-red-200',
                'success': 'bg-green-50 text-green-700 border-green-200',
                'info': 'bg-blue-50 text-blue-700 border-blue-200'
            };
            el.className = `mb-4 p-3 rounded-md text-sm border ${colors[type] || colors['info']}`;
        }

        function enableDownload(enable) {
            const btn = document.getElementById('btnDownload');
            if(enable) {
                btn.disabled = false;
                btn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            } else {
                btn.disabled = true;
                btn.classList.add('bg-gray-400', 'cursor-not-allowed');
                btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            }
        }

        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => { initApp(); });

        async function initApp() {
            try {
                const canvas = document.getElementById('previewCanvas');
                if(!canvas) throw new Error("Canvas mancante.");
                
                paper.setup(canvas);
                paperProject = paper.project;

                setStatus("Caricamento Font...", 'info');

                let buffer = null;
                for (const url of FONT_URLS) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) {
                            buffer = await response.arrayBuffer();
                            break;
                        }
                    } catch (e) { console.warn("Fallback font...", e); }
                }

                if (!buffer) throw new Error("Impossibile scaricare il font.");
                
                font = opentype.parse(buffer);
                isReady = true;
                setStatus('Sistema Pronto. Scrivi per generare.', 'success');
                updatePreview();

            } catch(e) {
                console.error(e);
                setStatus("Errore: " + e.message, 'error');
            }
        }

        // --- Logica Core ---
        window.scheduleUpdate = function() {
            if(!isReady) return;
            enableDownload(false);
            document.getElementById('calcStatus').innerText = "Elaborazione...";
            if(updateTimer) clearTimeout(updateTimer);
            updateTimer = setTimeout(updatePreview, 600);
        }

        function updatePreview() {
            if (!font || !paperProject) return;
            
            paperProject.activeLayer.removeChildren();

            const textVal = document.getElementById('inputText').value.toUpperCase(); 
            if(!textVal) { setStatus("Inserisci un testo.", 'info'); return; }

            const fontSize = parseInt(document.getElementById('fontSize').value) || 100;
            const spacing = parseFloat(document.getElementById('hatchSpacing').value) || 0.5;
            const angleDeg = parseFloat(document.getElementById('hatchAngle').value) || 45;
            const showOutline = document.getElementById('includeOutline').checked;

            try {
                // 1. Genera tracciato grezzo
                const pathData = font.getPath(textVal, 0, 0, fontSize).toPathData(2);
                let rawTextItem = new paper.CompoundPath(pathData);
                
                // 2. UNIONE BOOLEANA (Fix per lettere sovrapposte come la 'E')
                // Questo passaggio fonde tutti i pezzi della lettera in un unico solido
                let solidTextItem;
                
                if (rawTextItem.children && rawTextItem.children.length > 0) {
                    // Se ci sono più parti (es. buco della O, o rettangoli della E)
                    // Partiamo dal primo pezzo e uniamo gli altri
                    // Usiamo 'unite' che gestisce sia unioni che buchi (in base al winding)
                    
                    // Cloniamo il primo figlio per iniziare
                    solidTextItem = rawTextItem.children[0].clone();
                    
                    for (let i = 1; i < rawTextItem.children.length; i++) {
                        let nextPart = rawTextItem.children[i];
                        // Eseguiamo l'unione booleana
                        let united = solidTextItem.unite(nextPart);
                        // Rimuoviamo il vecchio pezzo intermedio per non sporcare la memoria
                        solidTextItem.remove(); 
                        solidTextItem = united;
                    }
                } else {
                    // Se è un tracciato semplice senza figli
                    solidTextItem = rawTextItem.clone();
                }

                // Pulizia: rimuoviamo l'originale grezzo che potrebbe avere intersezioni
                rawTextItem.remove();

                // Impostiamo lo stile del testo unito
                solidTextItem.fillColor = null;
                solidTextItem.strokeColor = showOutline ? '#0000FF' : null;
                solidTextItem.strokeWidth = 1.5;
                solidTextItem.position = paper.view.center;

                // 3. Campitura (Ray Casting su Geometria Pulita)
                const bounds = solidTextItem.bounds;
                const diag = Math.sqrt(bounds.width**2 + bounds.height**2);
                const count = Math.ceil(diag / spacing) * 1.5;
                const startX = bounds.center.x - (diag / 2);
                
                finalHatchGroup = new paper.Group();
                finalOutlineGroup = solidTextItem; // Usiamo la versione unita per l'export

                for(let i = 0; i < count; i++) {
                    const x = startX + (i * spacing);
                    const p1 = new paper.Point(x, bounds.center.y - (diag / 2));
                    const p2 = new paper.Point(x, bounds.center.y + (diag / 2));
                    
                    const rawLine = new paper.Path.Line(p1, p2);
                    rawLine.rotate(angleDeg - 90, bounds.center);

                    // Calcolo intersezioni sulla geometria pulita (solidTextItem)
                    const intersections = rawLine.getIntersections(solidTextItem);
                    
                    if(intersections.length > 0) {
                        const sortedIntersections = intersections.sort((a, b) => {
                            return a.point.getDistance(rawLine.firstSegment.point) - b.point.getDistance(rawLine.firstSegment.point);
                        });

                        let pointsToCheck = [rawLine.firstSegment.point];
                        sortedIntersections.forEach(int => pointsToCheck.push(int.point));
                        pointsToCheck.push(rawLine.lastSegment.point);

                        for(let j=0; j < pointsToCheck.length - 1; j++) {
                            const segStart = pointsToCheck[j];
                            const segEnd = pointsToCheck[j+1];
                            const midPoint = segStart.add(segEnd).divide(2);

                            // Verifica 'contains' sulla geometria unita
                            if(solidTextItem.contains(midPoint)) {
                                const hatchSegment = new paper.Path.Line(segStart, segEnd);
                                hatchSegment.strokeColor = '#FF0000';
                                hatchSegment.strokeWidth = 1;
                                finalHatchGroup.addChild(hatchSegment);
                            }
                        }
                    }
                    rawLine.remove();
                }

                solidTextItem.visible = showOutline;
                paper.view.draw();
                
                document.getElementById('calcStatus').innerText = "Pronto";
                enableDownload(true);

            } catch (err) {
                console.error(err);
                setStatus("Errore calcolo: " + err.message, 'error');
            }
        }

        // --- Export DXF ---
        function downloadDXF() {
            if (!finalHatchGroup) return;

            let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n";

            function writeLine(x1, y1, x2, y2, layer) {
                // Inversione Y per compatibilità CAD
                dxf += "0\nLINE\n8\n" + layer + "\n";
                dxf += "10\n" + x1.toFixed(4) + "\n20\n" + (-y1).toFixed(4) + "\n";
                dxf += "11\n" + x2.toFixed(4) + "\n21\n" + (-y2).toFixed(4) + "\n";
            }

            // Hatch
            finalHatchGroup.children.forEach(item => {
                if(item.segments && item.segments.length >= 2) {
                    writeLine(item.segments[0].point.x, item.segments[0].point.y, 
                             item.segments[1].point.x, item.segments[1].point.y, "HATCH");
                }
            });

            // Outline Unito
            if(document.getElementById('includeOutline').checked && finalOutlineGroup) {
                const flatOutline = finalOutlineGroup.clone();
                flatOutline.flatten(0.5); 
                
                const processNode = (node) => {
                    if(node.children) node.children.forEach(processNode);
                    else if(node.segments) {
                        for(let s=0; s<node.segments.length; s++) {
                            const p1 = node.segments[s].point;
                            const nextIdx = (s + 1) % node.segments.length;
                            if(!node.closed && nextIdx === 0) continue;
                            const p2 = node.segments[nextIdx].point;
                            writeLine(p1.x, p1.y, p2.x, p2.y, "OUTLINE");
                        }
                    }
                };
                processNode(flatOutline);
                flatOutline.remove();
            }

            dxf += "0\nENDSEC\n0\nEOF\n";

            const blob = new Blob([dxf], {type: 'application/dxf'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = "Laser_" + document.getElementById('inputText').value + ".dxf";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>
