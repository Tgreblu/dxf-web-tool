<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore DXF per Laser - Parabiago Edition</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Paper.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
    <!-- Opentype.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        /* Altezza fissa per il canvas per evitare glitch di ridimensionamento */
        canvas[resize] { width: 100%; height: 400px; border: 1px solid #ccc; background-color: #fff; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4">

    <div class="max-w-4xl mx-auto bg-white rounded-lg shadow-lg p-6">
        <h1 class="text-2xl font-bold text-gray-800 mb-2">Generatore Campitura Laser (DXF R13)</h1>
        
        <!-- Area Stato/Errori -->
        <div id="appStatus" class="mb-4 p-3 bg-blue-50 text-blue-700 rounded-md text-sm border border-blue-200">
            Inizializzazione sistema...
        </div>

        <p class="text-gray-600 mb-6 text-sm">
            Inserisci il testo, imposta i parametri e genera un file DXF con linee fisiche (Loop Nesting automatico).
        </p>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <!-- Controlli -->
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Testo da marcare</label>
                    <input type="text" id="inputText" value="PARABIAGO" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2 focus:border-blue-500 focus:ring-blue-500" oninput="scheduleUpdate()">
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Spaziatura Linee (mm)</label>
                        <input type="number" id="hatchSpacing" value="0.5" step="0.1" min="0.1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2" onchange="scheduleUpdate()">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Angolo (gradi)</label>
                        <input type="number" id="hatchAngle" value="45" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2" onchange="scheduleUpdate()">
                    </div>
                </div>

                <div>
                     <label class="block text-sm font-medium text-gray-700">Dimensione Testo (px/unità)</label>
                     <input type="number" id="fontSize" value="150" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2" onchange="scheduleUpdate()">
                </div>
                
                <div class="flex items-center space-x-2 mt-2">
                     <input type="checkbox" id="includeOutline" checked onchange="scheduleUpdate()" class="rounded text-blue-600 focus:ring-blue-500">
                     <label for="includeOutline" class="text-sm text-gray-700">Includi Perimetro (Contorno)</label>
                </div>

                <div class="pt-4">
                    <button id="btnDownload" onclick="downloadDXF()" disabled class="w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-gray-400 cursor-not-allowed transition-colors">
                        <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                        Scarica File DXF
                    </button>
                    <p id="calcStatus" class="text-xs text-center mt-2 text-gray-500"></p>
                </div>
            </div>

            <!-- Preview -->
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Anteprima</label>
                <!-- Canvas Paper.js -->
                <canvas id="previewCanvas" resize></canvas>
            </div>
        </div>
        
        <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 mt-4">
            <p class="text-sm text-yellow-700">
                <strong>Nota:</strong> Se non vedi l'anteprima dopo qualche secondo, prova a ricaricare la pagina.
            </p>
        </div>
    </div>

    <!-- Logica Applicativa -->
    <script type="text/javascript">
        // --- Variabili Globali ---
        let font = null;
        let paperProject = null;
        let finalHatchGroup = null;
        let finalOutlineGroup = null;
        let updateTimer = null;
        let isReady = false;

        // URL del font - USIAMO UN FILE .TTF (TrueType) invece di .WOFF2 per compatibilità
        // Fonte: Google Fonts repo via jsDelivr CDN (molto affidabile)
        const FONT_URL = 'https://cdn.jsdelivr.net/gh/google/fonts/apache/roboto/Roboto-Regular.ttf';

        // --- Funzioni di Utility UI ---
        function setStatus(msg, type = 'info') {
            const el = document.getElementById('appStatus');
            el.innerText = msg;
            if(type === 'error') {
                el.className = "mb-4 p-3 bg-red-50 text-red-700 rounded-md text-sm border border-red-200";
            } else if (type === 'success') {
                el.className = "mb-4 p-3 bg-green-50 text-green-700 rounded-md text-sm border border-green-200";
            } else {
                el.className = "mb-4 p-3 bg-blue-50 text-blue-700 rounded-md text-sm border border-blue-200";
            }
        }

        function enableDownload(enable) {
            const btn = document.getElementById('btnDownload');
            if(enable) {
                btn.disabled = false;
                btn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            } else {
                btn.disabled = true;
                btn.classList.add('bg-gray-400', 'cursor-not-allowed');
                btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            }
        }

        // --- Inizializzazione ---
        document.addEventListener('DOMContentLoaded', () => {
            initApp();
        });

        function initApp() {
            try {
                // Setup Paper.js
                const canvas = document.getElementById('previewCanvas');
                if(!canvas) throw new Error("Canvas non trovato nella pagina.");
                
                paper.setup(canvas);
                paperProject = paper.project;

                setStatus("Caricamento Font (.ttf) in corso...", 'info');

                // Caricamento Font
                opentype.load(FONT_URL, function(err, f) {
                    if (err) {
                        console.error(err);
                        setStatus('Errore caricamento Font: ' + err, 'error');
                    } else {
                        font = f;
                        isReady = true;
                        setStatus('Sistema Pronto. Modifica il testo per generare.', 'success');
                        // Primo render automatico
                        updatePreview();
                    }
                });

            } catch(e) {
                setStatus("Errore critico di inizializzazione: " + e.message, 'error');
            }
        }

        // --- Logica di Aggiornamento ---
        window.scheduleUpdate = function() {
            if(!isReady) return;
            enableDownload(false);
            document.getElementById('calcStatus').innerText = "Ricalcolo geometria...";
            
            if(updateTimer) clearTimeout(updateTimer);
            updateTimer = setTimeout(updatePreview, 600); // 600ms delay
        }

        function updatePreview() {
            if (!font || !paperProject) return;
            
            // Reset Canvas
            paperProject.activeLayer.removeChildren();

            // Parametri input
            const textVal = document.getElementById('inputText').value.toUpperCase(); // Forziamo maiuscolo per estetica laser
            if(!textVal) {
                setStatus("Inserisci un testo.", 'info');
                return;
            }

            const fontSize = parseInt(document.getElementById('fontSize').value) || 100;
            const spacing = parseFloat(document.getElementById('hatchSpacing').value) || 0.5;
            const angleDeg = parseFloat(document.getElementById('hatchAngle').value) || 45;
            const showOutline = document.getElementById('includeOutline').checked;

            try {
                // 1. Converti testo in tracciato (Path Data)
                const pathData = font.getPath(textVal, 0, 0, fontSize).toPathData(2);
                
                // 2. Crea oggetto Paper.js (CompoundPath gestisce i buchi)
                const textItem = new paper.CompoundPath(pathData);
                textItem.fillColor = null; // Nessun riempimento solido
                textItem.strokeColor = showOutline ? '#0000FF' : null; // Blu per contorno
                textItem.strokeWidth = 1;
                
                // Centra nella vista
                textItem.position = paper.view.center;

                // 3. Generazione Campitura (Hatch)
                // Strategia: Creare una griglia di linee enorme e tagliarla con la forma del testo
                
                const bounds = textItem.bounds;
                // Calcolo dimensione diagonale per coprire tutto durante la rotazione
                const diag = Math.sqrt(bounds.width**2 + bounds.height**2);
                const count = Math.ceil(diag / spacing) * 1.5;

                // Gruppo temporaneo per le linee grezze
                const rawLines = new paper.Group();
                
                // Generiamo linee verticali centrate sull'oggetto
                const startX = bounds.center.x - (diag / 2);
                
                for(let i = 0; i < count; i++) {
                    const x = startX + (i * spacing);
                    // Linea lunga quanto la diagonale
                    const p1 = new paper.Point(x, bounds.center.y - (diag / 2));
                    const p2 = new paper.Point(x, bounds.center.y + (diag / 2));
                    const line = new paper.Path.Line(p1, p2);
                    rawLines.addChild(line);
                }

                // Ruotiamo il gruppo di linee
                // Nota: le linee sono verticali (90°). Se l'utente vuole 45°, ruotiamo di (45-90) = -45
                // O semplicemente ruotiamo dell'angolo desiderato se partiamo da una base corretta.
                // Ruotiamo tutto il blocco linee attorno al centro del testo
                rawLines.rotate(angleDeg - 90, bounds.center);

                // 4. Intersezione (Clipping)
                // Usiamo intersect. Attenzione: Intersecare molte linee con un complex path può essere lento.
                // Ottimizzazione: Usare intersect su tutto il gruppo spesso fallisce in JS puri.
                // Meglio iterare.
                
                finalHatchGroup = new paper.Group(); // Contenitore finale
                finalOutlineGroup = textItem; // Riferimento per export

                const lines = rawLines.children;
                // Rimuoviamo rawLines dalla scena visibile per non confondere
                rawLines.remove(); 

                // Processiamo ogni linea
                for(let i=0; i<lines.length; i++) {
                    const rawLine = lines[i];
                    // La magia di Paper.js: interseca la linea infinita con la forma del testo
                    // Restituisce solo i segmenti che stanno "sopra" il riempimento del testo (quindi gestisce i buchi)
                    const clipped = textItem.intersect(rawLine, {trace: false});
                    
                    if(clipped) {
                        // Se l'intersezione esiste
                        clipped.strokeColor = '#FF0000'; // Rosso per campitura
                        clipped.strokeWidth = 1;
                        finalHatchGroup.addChild(clipped);
                    }
                }

                // Se non vogliamo il contorno, nascondiamolo ma teniamolo in memoria per i calcoli
                textItem.visible = showOutline;
                
                // Aggiorna vista
                paper.view.draw();
                
                document.getElementById('calcStatus').innerText = "Pronto";
                enableDownload(true);

            } catch (err) {
                console.error(err);
                setStatus("Errore durante il calcolo geometrico: " + err.message, 'error');
            }
        }

        // --- Generazione DXF ---
        function downloadDXF() {
            if (!finalHatchGroup) return;

            // Inizio costruzione file DXF
            let dxf = "";
            dxf += "0\nSECTION\n2\nHEADER\n0\nENDSEC\n";
            dxf += "0\nSECTION\n2\nENTITIES\n";

            // Funzione helper per scrivere LINE nel DXF
            function writeLine(x1, y1, x2, y2, layer) {
                // Invertiamo Y perché in Canvas Y cresce verso il basso, in DXF/CAD verso l'alto
                // Se la tua macchina lo importa specchiato, prova a rimuovere il segno meno su y1/y2
                dxf += "0\nLINE\n";
                dxf += "8\n" + layer + "\n"; // Nome Layer
                dxf += "10\n" + x1.toFixed(4) + "\n"; // X Start
                dxf += "20\n" + (-y1).toFixed(4) + "\n"; // Y Start (Inverted)
                dxf += "11\n" + x2.toFixed(4) + "\n"; // X End
                dxf += "21\n" + (-y2).toFixed(4) + "\n"; // Y End (Inverted)
            }

            // 1. Esporta Campitura (Rosso) -> Layer "HATCH"
            // Le intersezioni possono essere Path composti da più curve o segmenti
            const items = finalHatchGroup.children;
            for(let i=0; i<items.length; i++) {
                const item = items[i];
                // Paper.js a volte restituisce Path complessi anche per linee dritte intersecate
                // Iteriamo sulle curve (che in realtà sono segmenti retti qui)
                if(item.curves) {
                    for(let c=0; c<item.curves.length; c++) {
                        const curve = item.curves[c];
                        writeLine(curve.point1.x, curve.point1.y, curve.point2.x, curve.point2.y, "HATCH");
                    }
                }
            }

            // 2. Esporta Contorno (Blu) -> Layer "OUTLINE"
            const showOutline = document.getElementById('includeOutline').checked;
            if(showOutline && finalOutlineGroup) {
                // Il contorno è curvo. Dobbiamo discretizzarlo in segmenti retti per compatibilità DXF R12
                const flatOutline = finalOutlineGroup.clone();
                flatOutline.flatten(0.5); // Converte curve in linee con tolleranza 0.5px
                
                // Funzione ricorsiva per gestire CompoundPath (es. lettere con buchi)
                function processItem(node) {
                    if(node.children) {
                        node.children.forEach(processItem);
                    } else if(node.segments) {
                        for(let s=0; s<node.segments.length; s++) {
                            const p1 = node.segments[s].point;
                            // Collega al prossimo punto (o al primo se chiuso)
                            const nextIdx = (s + 1) % node.segments.length;
                            // Se non è chiuso e siamo alla fine, stop
                            if(!node.closed && nextIdx === 0) continue;
                            
                            const p2 = node.segments[nextIdx].point;
                            writeLine(p1.x, p1.y, p2.x, p2.y, "OUTLINE");
                        }
                    }
                }
                processItem(flatOutline);
                flatOutline.remove(); // Pulizia memoria
            }

            dxf += "0\nENDSEC\n0\nEOF\n";

            // Download
            const blob = new Blob([dxf], {type: 'application/dxf'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = "Laser_" + document.getElementById('inputText').value + ".dxf";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>